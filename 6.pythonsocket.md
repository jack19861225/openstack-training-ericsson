#Python Socket编程练习

Python 提供了两个基本的 socket 模块。
   - 第一个是 Socket，它提供了标准的 BSD Sockets API。
   - 第二个是 SocketServer， 它提供了服务器中心类，可以简化网络服务器的开发
   
##练习1.简单的tcp 服务端与客户端通信

```

server 

if __name__ == '__main__':
    import socket
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.bind(('localhost', 8001))
    sock.listen(5)
    while True:
        connection,address = sock.accept()
        try:
            connection.settimeout(5)
            buf = connection.recv(1024)
            if buf == '1':
                connection.send('welcome to server!')
            else:
                connection.send('please go out!')
        except socket.timeout:
            print 'time out'
        connection.close()

client

if __name__ == '__main__':
    import socket
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.connect(('localhost', 8001))
    import time
    time.sleep(2)
    sock.send('1')
    print sock.recv(1024)
    sock.close()



```

##练习2.错误处理


如果创建 socket 函数失败，会抛出一个 socket.error 的异常，需要捕获：

```
import socket   #for sockets
import sys  #for exit
 
try:
    #create an AF_INET, STREAM socket (TCP)
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
except socket.error, msg:
    print 'Failed to create socket. Error code: ' + str(msg[0]) + ' , Error message : ' + msg[1]
    sys.exit();
 
print 'Socket Created'

```

##练习3.客户端基本操作

- 获得远程主机的 IP 地址
````
    remote_ip = socket.gethostbyname( host )
```
-  发送数据
```
   s.sendall(message)
```
- 接收数据
```
  reply = s.recv(4096)
```

##练习4.服务端基本操作

- 绑定端口
函数 bind 可以用来将 socket 绑定到特定的地址和端口上，它需要一个 sockaddr_in 结构作为参数：

```
    s.bind((HOST, PORT))
```
- 监听连接

函数 listen 可以将 socket 置于监听模式：

```
s.listen(10)
```
该函数带有一个参数称为 backlog，用来控制连接的个数。如果设为 10，那么有 10 个连接正在等待处理，此时第 11 个请求过来时将会被拒绝。

- 接收连接

当有客户端向服务器发送连接请求时，服务器会接收连接：
```
conn, addr = s.accept()
```
- 保持服务

```
while 1:
    #wait to accept a connection - blocking call
    conn, addr = s.accept()
    print 'Connected with ' + addr[0] + ':' + str(addr[1])
     
    data = conn.recv(1024)
    reply = 'OK...' + data
    if not data: 
        break
     
    conn.sendall(reply)
 
conn.close()
s.close()
```

现在在一个终端下运行上面的服务器程序，再开启三个终端，分别用 telnet 去连接，如果一个终端连接之后不输入数据其他终端是没办法进行连接的，而且每个终端只能服务一次就断开连接
这显然也不是我们想要的，我们希望多个客户端可以随时建立连接，而且每个客户端可以跟服务器进行多次通信.

- 处理连接

为了处理每个连接，我们需要将处理的程序与主程序的接收连接分开
一种方法可以使用线程来实现，主服务程序接收连接，创建一个线程来处理该连接的通信，然后服务器回到接收其他连接的逻辑上来
```
import socket
import sys
from thread import *

if __name__ == '__main__':

 
    HOST = '127.0.0.1'   # Symbolic name meaning all available interfaces
    PORT = 8888 # Arbitrary non-privileged port
     
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    print 'Socket created'
     
    try:
        s.bind((HOST, PORT))
    except socket.error , msg:
        print 'Bind failed. Error Code : '
        sys.exit()
         
    print 'Socket bind complete'
     
    s.listen(10)
    print 'Socket now listening'
     
    def clientthread(conn):

    try:
        conn.send('Welcome to the server. Type something and hit enter\n') #send only takes string
         
        #infinite loop so that function do not terminate and thread do not end.
            while True:
             
                data = conn.recv(1024)
                reply = 'OK...' + data
                if not data: 
                    break
         
                conn.sendall(reply)
                print reply
         
            conn.close()
        except socket.error , msg:
            print 'Bind failed. Error Code : '+str(msg[0]) + ' Message ' + msg[1]
            sys.exit()
         
    while 1:
        conn, addr = s.accept()
        print 'Connected with ' + addr[0] + ':' + str(addr[1])
         
        start_new_thread(clientthread ,(conn,))
     
    s.close()

```

##练习4.Socket编程进阶- 聊天室示例程序


